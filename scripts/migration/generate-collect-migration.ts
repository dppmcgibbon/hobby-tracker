/**
 * Generate migration SQL from collect CSV files.
 * Run: npx tsx scripts/migration/generate-collect-migration.ts
 */

import fs from "fs";
import path from "path";
import csv from "csv-parser";

function escapeSql(val: string | undefined | null): string {
  if (val === undefined || val === null || val === "") return "NULL";
  const s = String(val).replace(/'/g, "''");
  return `'${s}'`;
}

function toInt(val: string | undefined | null): string {
  if (val === undefined || val === null || val === "") return "NULL";
  const n = parseInt(val, 10);
  return isNaN(n) ? "NULL" : String(n);
}

function toBool(val: string | undefined | null): string {
  if (val === undefined || val === null || val === "") return "false";
  return ["1", "true", "yes"].includes(String(val).toLowerCase()) ? "true" : "false";
}

async function parseCsv(filePath: string): Promise<Record<string, string>[]> {
  return new Promise((resolve, reject) => {
    const rows: Record<string, string>[] = [];
    fs.createReadStream(filePath)
      .pipe(csv())
      .on("data", (row) => rows.push(row))
      .on("end", () => resolve(rows))
      .on("error", reject);
  });
}

async function main() {
  const baseDir = process.env.CSV_DIR || "/Users/daithi";
  const files = {
    collect_apps: path.join(baseDir, "collect_apps_202602200135.csv"),
    collect_config: path.join(baseDir, "collect_config_202602200137.csv"),
    boardgames: path.join(baseDir, "boardgames_202602200138.csv"),
    magazines: path.join(baseDir, "magazines_202602200138.csv"),
    records: path.join(baseDir, "records_202602200138.csv"),
    stories: path.join(baseDir, "stories_202602200138.csv"),
  };

  let sql = `-- Collect tables and data from CSV imports
-- Generated by scripts/migration/generate-collect-migration.ts

-- ========== collect_apps ==========
CREATE TABLE IF NOT EXISTS public.collect_apps (
  id INTEGER PRIMARY KEY,
  app TEXT NOT NULL,
  table_name TEXT NOT NULL,
  initial_sort_key TEXT
);

-- ========== collect_config ==========
CREATE TABLE IF NOT EXISTS public.collect_config (
  id INTEGER PRIMARY KEY,
  table_name TEXT NOT NULL,
  sequence INTEGER NOT NULL,
  column_name TEXT NOT NULL,
  column_type TEXT NOT NULL,
  display SMALLINT DEFAULT 0,
  initial_sort_key SMALLINT DEFAULT 0,
  filter SMALLINT DEFAULT 0
);

-- ========== boardgames ==========
CREATE TABLE IF NOT EXISTS public.boardgames (
  id INTEGER PRIMARY KEY,
  game TEXT NOT NULL,
  boxset TEXT NOT NULL,
  type TEXT NOT NULL,
  name TEXT NOT NULL,
  amount TEXT,
  status TEXT
);

-- ========== magazines ==========
CREATE TABLE IF NOT EXISTS public.magazines (
  id INTEGER PRIMARY KEY,
  magazine TEXT NOT NULL,
  issue INTEGER NOT NULL,
  faction TEXT,
  miniature TEXT,
  image TEXT,
  received BOOLEAN DEFAULT false,
  built BOOLEAN DEFAULT false,
  primed BOOLEAN DEFAULT false,
  painted BOOLEAN DEFAULT false,
  magnetised BOOLEAN DEFAULT false,
  complete BOOLEAN DEFAULT false
);

-- ========== records ==========
CREATE TABLE IF NOT EXISTS public.records (
  id INTEGER PRIMARY KEY,
  label TEXT NOT NULL,
  catalog TEXT,
  sequence INTEGER,
  artist TEXT,
  title TEXT NOT NULL,
  cassette BOOLEAN DEFAULT false,
  cd BOOLEAN DEFAULT false,
  vinyl BOOLEAN DEFAULT false,
  digital BOOLEAN DEFAULT false,
  bandcamp BOOLEAN DEFAULT false,
  discogs BOOLEAN DEFAULT false
);

-- ========== stories ==========
CREATE TABLE IF NOT EXISTS public.stories (
  id INTEGER PRIMARY KEY,
  author TEXT NOT NULL,
  sequence INTEGER NOT NULL,
  book TEXT,
  story TEXT NOT NULL,
  wiki TEXT,
  date TEXT,
  series TEXT,
  novel BOOLEAN DEFAULT false,
  complete BOOLEAN DEFAULT false
);

-- RLS
ALTER TABLE public.collect_apps ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.collect_config ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.boardgames ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.magazines ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.records ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.stories ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view collect_apps" ON public.collect_apps FOR SELECT USING (true);
CREATE POLICY "Anyone can view collect_config" ON public.collect_config FOR SELECT USING (true);
CREATE POLICY "Anyone can view boardgames" ON public.boardgames FOR SELECT USING (true);
CREATE POLICY "Anyone can view magazines" ON public.magazines FOR SELECT USING (true);
CREATE POLICY "Anyone can view records" ON public.records FOR SELECT USING (true);
CREATE POLICY "Anyone can view stories" ON public.stories FOR SELECT USING (true);

`;

  // collect_apps
  const collectApps = await parseCsv(files.collect_apps);
  sql += "INSERT INTO public.collect_apps (id, app, table_name, initial_sort_key) VALUES\n";
  sql += collectApps
    .map(
      (r) =>
        `(${toInt(r.id)}, ${escapeSql(r.app)}, ${escapeSql(r.tableName)}, ${escapeSql(r.initialSortKey)})`
    )
    .join(",\n");
  sql += "\nON CONFLICT (id) DO UPDATE SET app = EXCLUDED.app, table_name = EXCLUDED.table_name, initial_sort_key = EXCLUDED.initial_sort_key;\n\n";

  // collect_config
  const collectConfig = await parseCsv(files.collect_config);
  sql += "INSERT INTO public.collect_config (id, table_name, sequence, column_name, column_type, display, initial_sort_key, filter) VALUES\n";
  sql += collectConfig
    .map(
      (r) =>
        `(${toInt(r.id)}, ${escapeSql(r.tableName)}, ${toInt(r.sequence)}, ${escapeSql(r.columnName)}, ${escapeSql(r.columnType)}, ${toInt(r.display)}, ${toInt(r.initialSortKey)}, ${toInt(r.filter)})`
    )
    .join(",\n");
  sql += "\nON CONFLICT (id) DO UPDATE SET table_name = EXCLUDED.table_name, sequence = EXCLUDED.sequence, column_name = EXCLUDED.column_name, column_type = EXCLUDED.column_type, display = EXCLUDED.display, initial_sort_key = EXCLUDED.initial_sort_key, filter = EXCLUDED.filter;\n\n";

  // boardgames
  const boardgames = await parseCsv(files.boardgames);
  sql += "INSERT INTO public.boardgames (id, game, boxset, type, name, amount, status) VALUES\n";
  sql += boardgames
    .map(
      (r) =>
        `(${toInt(r.id)}, ${escapeSql(r.game)}, ${escapeSql(r.boxset)}, ${escapeSql(r.type)}, ${escapeSql(r.name)}, ${escapeSql(r.amount)}, ${escapeSql(r.status)})`
    )
    .join(",\n");
  sql += "\nON CONFLICT (id) DO UPDATE SET game = EXCLUDED.game, boxset = EXCLUDED.boxset, type = EXCLUDED.type, name = EXCLUDED.name, amount = EXCLUDED.amount, status = EXCLUDED.status;\n\n";

  // magazines
  const magazines = await parseCsv(files.magazines);
  sql += "INSERT INTO public.magazines (id, magazine, issue, faction, miniature, image, received, built, primed, painted, magnetised, complete) VALUES\n";
  sql += magazines
    .map(
      (r) =>
        `(${toInt(r.id)}, ${escapeSql(r.magazine)}, ${toInt(r.issue)}, ${escapeSql(r.faction)}, ${escapeSql(r.miniature)}, ${escapeSql(r.image)}, ${toBool(r.received)}, ${toBool(r.built)}, ${toBool(r.primed)}, ${toBool(r.painted)}, ${toBool(r.magnetised)}, ${toBool(r.complete)})`
    )
    .join(",\n");
  sql += "\nON CONFLICT (id) DO UPDATE SET magazine = EXCLUDED.magazine, issue = EXCLUDED.issue, faction = EXCLUDED.faction, miniature = EXCLUDED.miniature, image = EXCLUDED.image, received = EXCLUDED.received, built = EXCLUDED.built, primed = EXCLUDED.primed, painted = EXCLUDED.painted, magnetised = EXCLUDED.magnetised, complete = EXCLUDED.complete;\n\n";

  // records
  const records = await parseCsv(files.records);
  sql += "INSERT INTO public.records (id, label, catalog, sequence, artist, title, cassette, cd, vinyl, digital, bandcamp, discogs) VALUES\n";
  sql += records
    .map(
      (r) =>
        `(${toInt(r.id)}, ${escapeSql(r.label)}, ${escapeSql(r.catalog)}, ${toInt(r.sequence)}, ${escapeSql(r.artist)}, ${escapeSql(r.title)}, ${toBool(r.cassette)}, ${toBool(r.cd)}, ${toBool(r.vinyl)}, ${toBool(r.digital)}, ${toBool(r.bandcamp)}, ${toBool(r.discogs)})`
    )
    .join(",\n");
  sql += "\nON CONFLICT (id) DO UPDATE SET label = EXCLUDED.label, catalog = EXCLUDED.catalog, sequence = EXCLUDED.sequence, artist = EXCLUDED.artist, title = EXCLUDED.title, cassette = EXCLUDED.cassette, cd = EXCLUDED.cd, vinyl = EXCLUDED.vinyl, digital = EXCLUDED.digital, bandcamp = EXCLUDED.bandcamp, discogs = EXCLUDED.discogs;\n\n";

  // stories
  const stories = await parseCsv(files.stories);
  sql += "INSERT INTO public.stories (id, author, sequence, book, story, wiki, date, series, novel, complete) VALUES\n";
  sql += stories
    .map(
      (r) =>
        `(${toInt(r.id)}, ${escapeSql(r.author)}, ${toInt(r.sequence)}, ${escapeSql(r.book)}, ${escapeSql(r.story)}, ${escapeSql(r.wiki)}, ${escapeSql(r.date)}, ${escapeSql(r.series)}, ${toBool(r.novel)}, ${toBool(r.complete)})`
    )
    .join(",\n");
  sql += "\nON CONFLICT (id) DO UPDATE SET author = EXCLUDED.author, sequence = EXCLUDED.sequence, book = EXCLUDED.book, story = EXCLUDED.story, wiki = EXCLUDED.wiki, date = EXCLUDED.date, series = EXCLUDED.series, novel = EXCLUDED.novel, complete = EXCLUDED.complete;\n";

  const outPath = path.join(
    process.cwd(),
    "supabase/migrations/20250220000014_seed_collect_tables.sql"
  );
  fs.writeFileSync(outPath, sql);
  console.log(`Wrote migration to ${outPath}`);
  console.log(`  collect_apps: ${collectApps.length} rows`);
  console.log(`  collect_config: ${collectConfig.length} rows`);
  console.log(`  boardgames: ${boardgames.length} rows`);
  console.log(`  magazines: ${magazines.length} rows`);
  console.log(`  records: ${records.length} rows`);
  console.log(`  stories: ${stories.length} rows`);
}

main().catch(console.error);
